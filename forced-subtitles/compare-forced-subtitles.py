#!/usr/bin/env python3
import sys
import xml.etree.cElementTree as ET
import string
import pysrt
import argparse


def main():
    parser = argparse.ArgumentParser(
        prog=sys.argv[0],
        description="Find overlaps between forced and non-forced BDNXML subtitles",
    )
    parser.add_argument(
        "--input-xml",
        dest="BDNXML",
        type=str,
        help="BDNXML that contains both forced and non-forced subtitles.",
    )
    parser.add_argument(
        "--input-srt",
        dest="SRTFile",
        type=str,
        help="SRT of '--input-xml' generated by sup2srt.",
    )
    parser.add_argument(
        "--forced-xml",
        dest="BDNXML2",
        type=str,
        help="BDNXML that overlaps '--input-xml'.",
    )
    parser.add_argument(
        "--forced-srt",
        dest="SRTFile2",
        type=str,
        help="SRT of '--forced-xml' generated by sup2srt.",
    )
    args = parser.parse_args()

    for arg in [args.BDNXML, args.BDNXML2, args.SRTFile, args.SRTFile2]:
        if arg is None:
            print("Missing arguments!")
            parser.print_help()
            return 1

    BDNXML = args.BDNXML
    BDNXML2 = args.BDNXML2
    SRT: pysrt.SubRipFile = pysrt.open(args.SRTFile)  # SRT generated by sup2srt
    SRT2: pysrt.SubRipFile = pysrt.open(args.SRTFile2)

    tree1 = ET.parse(BDNXML)
    root1 = tree1.getroot()
    tree2 = ET.parse(BDNXML2)
    root2 = tree2.getroot()

    fps1 = getBnxmlFps(root1)
    fps2 = getBnxmlFps(root2)

    # Add sup2srt converted text to xml
    # (allows us to see if subs match)
    # "Was gonna attempt my own tesseract usage but for the life"
    # "of me I couldn't get tesseract to properly recognize a '?' character"
    counter = 0
    for event in root1.iter("Event"):
        event.set("sup2srtText", SRT[counter].text)
        counter += 1

    counter = 0
    for event in root2.iter("Event"):
        event.set("sup2srtText", SRT2[counter].text)
        counter += 1

    overlaps = 0
    for event in root1.iter("Event"):
        for event2 in root2.iter("Event"):
            if isOverlap(event, event2, fps1, fps2):
                if isMatching(event, event2):
                    event.set("Forced", "True")
                    overlaps += 1

    # Write BDNXML with forced enabled for comparison
    tree1.write(BDNXML.split(".xml")[0] + "-forced.xml")

    for event in root1.iter("Event"):
        if event.attrib["Forced"] in "False":
            event.set("Forced", "True")
        else:
            event.set("Forced", "False")
    tree1.write(BDNXML.split(".xml")[0] + "-nonforced.xml")

    print("Number of overlaps:", overlaps)


def tc2sec(timecode: str, framerate: float) -> float:
    # Timecode format %02d:%02d:%02d:%02d hour:minutes:seconds:frame
    hours = float(timecode.split(":")[0])
    minutes = float(timecode.split(":")[1])
    seconds = float(timecode.split(":")[2])
    frame = float(timecode.split(":")[3])

    hours2seconds = hours * 3600  # 60 minutes times 60
    minutes2seconds = minutes * 60
    frame2seconds = frame / framerate

    return hours2seconds + minutes2seconds + seconds + frame2seconds


def getBnxmlFps(BDNXMLroot: ET.Element) -> float:
    return float(next(BDNXMLroot.iter("Format")).attrib["FrameRate"])


def isMatching(event1: ET.Element, event2: ET.Element) -> bool:
    text1 = event1.attrib["sup2srtText"]
    text2 = event2.attrib["sup2srtText"]

    # For best results we should remove all punctuation and special characters.
    clean1 = text1.translate(str.maketrans("", "", string.punctuation)).strip().lower()
    clean2 = text2.translate(str.maketrans("", "", string.punctuation)).strip().lower()

    # clean up spaces too
    clean1 = " ".join(clean1.split())
    clean2 = " ".join(clean2.split())

    if clean2 in clean1:
        return True

    return False


def isOverlap(event1: ET.Element, event2: ET.Element, fps1: float, fps2: float) -> bool:
    in1 = tc2sec(event1.attrib["InTC"], fps1)
    out1 = tc2sec(event1.attrib["OutTC"], fps1)
    in2 = tc2sec(event2.attrib["InTC"], fps2)
    out2 = tc2sec(event2.attrib["OutTC"], fps2)

    latestStart = max(in1, in2)
    earliestEnd = min(out1, out2)

    delta = earliestEnd - latestStart

    if delta > 0:
        return True
    return False


if __name__ == "__main__":
    main()
